/*
 * Copyright 2022 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.cloud.verticals.foundations.dataharmonization.lsp;

import static com.google.common.truth.Truth.assertThat;
import static java.nio.charset.StandardCharsets.UTF_8;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;
import org.eclipse.lsp4j.CompletionItem;
import org.eclipse.lsp4j.CompletionList;
import org.eclipse.lsp4j.CompletionParams;
import org.eclipse.lsp4j.Diagnostic;
import org.eclipse.lsp4j.DiagnosticSeverity;
import org.eclipse.lsp4j.DidChangeTextDocumentParams;
import org.eclipse.lsp4j.DidOpenTextDocumentParams;
import org.eclipse.lsp4j.DidSaveTextDocumentParams;
import org.eclipse.lsp4j.Position;
import org.eclipse.lsp4j.Range;
import org.eclipse.lsp4j.TextDocumentContentChangeEvent;
import org.eclipse.lsp4j.TextDocumentIdentifier;
import org.eclipse.lsp4j.TextDocumentItem;
import org.eclipse.lsp4j.VersionedTextDocumentIdentifier;
import org.eclipse.lsp4j.jsonrpc.messages.Either;
import org.eclipse.lsp4j.services.TextDocumentService;

/** Class that provides utility functions for integration tests using TextDocumentServiceImpl. */
public class TextDocumentServiceImplTestUtil {

  private TextDocumentServiceImplTestUtil() {}

  /**
   * Helper function which returns the function names that are generated by the text document
   * service completion method. Takes as input the path to the input test file and a line and
   * position number from which to generate an autocomplete request.
   */
  protected static List<String> getCompletionItems(
      TextDocumentService textDocumentService, String filePath, int line, int position)
      throws IOException {
    // Open the text document
    openTextDocument(textDocumentService, filePath);
    // Send a completion request
    String wstlURI = "res:///" + filePath;
    CompletionParams completionParams = new CompletionParams();
    TextDocumentIdentifier textDocumentIdentifier = new TextDocumentIdentifier();
    textDocumentIdentifier.setUri(wstlURI);
    completionParams.setTextDocument(textDocumentIdentifier);

    completionParams.setPosition(new Position(line, position));

    Either<List<CompletionItem>, CompletionList> completionResponse =
        textDocumentService.completion(completionParams).join();
    // Extract the function names from the completed item responses
    List<String> functionNames = new ArrayList<>();
    completionResponse
        .getLeft()
        .forEach(
            completedItem -> {
              functionNames.add(completedItem.getLabel());
              assertThat(completedItem.getTextEdit()).isNotNull();
            });

    return functionNames;
  }

  protected static List<String> getCompletionSignature(
      TextDocumentService textDocumentService, String filePath, int line, int position)
      throws IOException {
    // Open the text document
    openTextDocument(textDocumentService, filePath);
    // Send a completion request
    String wstlUri = "res:///" + filePath;
    CompletionParams completionParams = new CompletionParams();
    TextDocumentIdentifier textDocumentIdentifier = new TextDocumentIdentifier();
    textDocumentIdentifier.setUri(wstlUri);
    completionParams.setTextDocument(textDocumentIdentifier);

    completionParams.setPosition(new Position(line, position));

    Either<List<CompletionItem>, CompletionList> completionResponse =
        textDocumentService.completion(completionParams).join();
    // Extract the function names from the completed item responses
    List<String> functionNames = new ArrayList<>();
    completionResponse
        .getLeft()
        .forEach(
            completedItem ->
                functionNames.add(completedItem.getTextEdit().getRight().getNewText()));
    return functionNames;
  }

  public static void openTextDocument(TextDocumentService textDocumentService, String filePath)
      throws IOException {
    // Open the test file and send a didOpenTextDocument action to the service.
    InputStream is = TextDocumentServiceImplTestUtil.class.getResourceAsStream("/" + filePath);
    if (is == null) {
      throw new FileNotFoundException(String.format("Fail to load %s from resources.", filePath));
    }
    String wstlInput = new String(is.readAllBytes(), UTF_8);
    String wstlURI = "res:///" + filePath;

    TextDocumentItem textDocumentItem = new TextDocumentItem();
    textDocumentItem.setUri(wstlURI);
    textDocumentItem.setText(wstlInput);
    DidOpenTextDocumentParams didOpenTextDocumentParams =
        new DidOpenTextDocumentParams(textDocumentItem);
    textDocumentService.didOpen(didOpenTextDocumentParams);
  }

  public static void saveTextDocument(
      TextDocumentService textDocumentService, String filePath, String wstlText) {
    String wstlURI = "res:///" + filePath;
    TextDocumentIdentifier textDocumentIdentifier = new TextDocumentIdentifier(wstlURI);
    DidSaveTextDocumentParams didSaveTextDocumentParams =
        new DidSaveTextDocumentParams(textDocumentIdentifier, wstlText);
    textDocumentService.didSave(didSaveTextDocumentParams);
  }

  public static void changeTextDocument(
      TextDocumentService textDocumentService,
      String filePath,
      List<TextDocumentContentChangeEvent> changeEvents) {
    String wstlURI = "res:///" + filePath;
    VersionedTextDocumentIdentifier versionedTextDocumentIdentifier =
        new VersionedTextDocumentIdentifier(wstlURI, 1);
    DidChangeTextDocumentParams didChangeTextDocumentParams =
        new DidChangeTextDocumentParams(versionedTextDocumentIdentifier, changeEvents);
    textDocumentService.didChange(didChangeTextDocumentParams);
  }

  public static Diagnostic createDiagnosticError(
      int[] startPos, int[] endPos, String diagnosticSource, String errorMessage) {
    return createDiagnostic(
        startPos, endPos, DiagnosticSeverity.Error, diagnosticSource, errorMessage);
  }

  static Diagnostic createDiagnosticWarning(
      int[] startPos, int[] endPos, String wstlURI, String message) {
    return createDiagnostic(startPos, endPos, DiagnosticSeverity.Warning, wstlURI, message);
  }

  // Helper function to create Diagnostic objects
  // the line number (first element of startPos and endPos) is 0-indexed and column number (second
  // element in startPos and endPos) is 1-indexed.
  public static Diagnostic createDiagnostic(
      int[] startPos,
      int[] endPos,
      DiagnosticSeverity severity,
      String diagnosticSource,
      String message) {
    Position start = new Position(startPos[0], startPos[1]);
    Position end = new Position(endPos[0], endPos[1]);
    Range range = new Range(start, end);

    Diagnostic diagnostic = new Diagnostic();
    diagnostic.setRange(range);
    diagnostic.setSeverity(severity);

    diagnostic.setSource(diagnosticSource);
    diagnostic.setMessage(message);

    return diagnostic;
  }

  protected static String getAbsolutePathToResourceFolder() {
    String path = "src/test/resources";
    File file = new File(path);
    return file.getAbsolutePath();
  }
}
